* flutter原理
** links
[[https://www.didierboelens.com/2019/09/flutter-internals/][flutter internals]]
** graphic engine
It use [[https://skia.org/user/download][skia]] as it's graphic engine.
*** How window call the skia.
*** What's skia's backend.
* binder原理
* threadloal
man code:
#+BEGIN_SRC java
    public T get() {
        Thread t = Thread.currentThread();
        ThreadLocalMap map = getMap(t);
        if (map != null) {
            ThreadLocalMap.Entry e = map.getEntry(this);
            if (e != null) {
                @SuppressWarnings("unchecked")
                T result = (T)e.value;
                return result;
            }
        }
        return setInitialValue();
    }
#+END_SRC
When new a thread, that thread intial a threadLocals map.
Then I new a ThreadLocal(), then I call threadLocal. What did it do??

I first retrive the current thread's the threadLocoals map. The threadLocals map key is the threadLocal it self.
Then I can get the value by the threadLocal key.

** extension
*** What does the Thread.currentThread() do.
    key code:
#+BEGIN_SRC cpp
// jvm.cpp

JVM_ENTRY(jobject, JVM_CurrentThread(JNIEnv* env, jclass threadClass))
  JVMWrapper("JVM_CurrentThread");
  oop jthread = thread->threadObj();
  assert(jthread != NULL, "no current thread!");
  return JNIHandles::make_local(THREAD, jthread);
JVM_END
#+END_SRC

**** TODO but I can't figure out where the thead come from

* looper原理
  A Looper class has a static thread local variable `sThreadLocal`. 
When call static Looper.prepare. set sThreadLocal variable a new Looper(). And after that, when call Looper.get() from same thread, get the same value.

A looper has a queue.

A Handler has a looper. when post to handler, is post to the queue.


** loop
loop() key code:
#+BEGIN_SRC java
        for (;;) {
            Message msg = queue.next(); // might block
            ...
#+END_SRC

* 锁原理
* Hashmap
  The hashmap backend is a array, and the node is a single link lilst.

When the size > threshold, we will expand the array.

When the list is too long, we will conver the list to a red-black tree.
* ConcurrentHashMap implements
  锁原理没有去看过。只知道怎么用。以及比较表面的东西。
* glide原理
  There are some optimization in glide

  
** Memory Cache and DisCache
和其它图片加载框架一样，有两层缓存MemoryCache and DiskCache

MemoryCache为LRU cache。但是我在实现里面没有看到LRU的逻辑，就是一个LinkedHashMap。莫非里面的实现有实现这个逻辑，还没有去看。

** Engine request resource.
   Frist load from memory. Then user ~DataFatcher~. 

** Why AndroidResourceSignature don't user resourceId?
   
   
** How listen resource for view recycle.
* okhttp原理
* https数据签名
* 安卓签名v1、v2、v3、v4的区别
 
